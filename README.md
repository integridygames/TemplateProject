# Base IntegridyGames Architecture #

## Общее описание ##

В проекте используется [Zenject](https://github.com/modesttree/Zenject).

Присутствует шаблонная сцена SampleScene,
где можно посмотреть базовый набор необходимых компонентов.
Основная цель архитектуры - подвести под единый принцип внедрение нового функционала, увеличить оптимизацию, упростить
соместную разработку и
сделать возможным переиспользование кода из других проектов.

## GameStartup ##

Содержит вызовы всех систем: `IInitializeSystem`, `IPreInitializeSystem`, `IUpdateSystem`, `IFixedUpdateSystem`,
`ICoroutineSystem`, `IDestroySystem`.

## Systems ##

Вместо вызовов большинства стандартных событий логики Unity: Awake, Start, Update, FixedUpdate, в архитектуре используется
сущность системы для обработки логики. Она точно нужна для обработки ргеулярной логики, и, зачастую, для обработка разовой инициализирующей логики. 
IDestroySystem - для логики завершения состояний и игры в целом. 
Также присутствует система, для асинхронного выполнений логики - ICoroutineSystem.

Для создания системы, необходимо реализовать один из интерфейсов:
* IInitializeSystem 
* IPreInitializeSystem 
* IUpdateSystem 
* IFixedUpdateSystem 
* ICoroutineSystem
* IDestroySystem.

Помимо этого нужно добавить систему в DI-Container вызовом одного из статических методов
`Container.Bind"SystemType"System<TSystem>()` или `Container.Bind"SystemType"SystemToWithState<TSystem>()`, 
где вместо `"SystemType"` будет Initializable, Update, FixedUpdate и т.д..

## States ##

По-скольку архитектура больше заточена под HyperCasual жанр, она не предполгает
использование сцен как глобальные состояния. Вместо этого мы будем использовать свои кастомные состояния.
Существует класс `StateBase`. Для создания нового состояние нужно его унаследовать. 
При необходимости возможно добавить логику, которая будет выполняться при активации состояния и его деакцивации
переопределив методы `OnActivate()` и `OnDeactivate()`.

## Transitions ##

Для оперирования состояниями используются наследники класса `TransitionBase`. 
Они нужно чтобы определить в какой последовательности и при каких условиях будут переключаться состояния.
Наследник класса, где-то внутри себя обязан вызвать свой же базовый метод `DoTranisition()`.
В конструктор класса передается состояние, из которого мы будем переходить, а также целевое состояние.
Список нужных зависимостей можно расширять в конкретной реализации.

Для создания состояния необходимо вызвать у Di-контейнера метод `Container.CreateAndBindTransition<TTransitionType>(StateBase startState,
StateBase endState)`.

## Привязка систем к состояниям ##

Важным элементом архитектуры является возможность связывать системы с 
конкретными состояниями. Сейчас существует проблемное место - необходимость делать всё это в одном
инсталлере. Как правило, в проекте существует класс `SystemsStatesInstaller`, в котором и происходит связка систем с состояниями.
Это не означает, что не может быть систем, которые работают независимо от состояний, такие тоже можно создавать.

В `SystemsStatesInstaller` создаются States, затем создаются Transitions, затем Systems. 
Если систему связать с конкретным состоянием, то она будет работать только когда активно конкретное состояние.
Мы можем связать систему с двумя или любым множеством состояний, чтобы она работала только когда они активны.
Если привязать инициализирующую систему к состоянию, то она будет вызываться каждый раз, когда состояние 
активируется, аналогичная логика с реализациями `IDestroySystem`.

## Views ##

Наследуется от `ViewBase`. Служит для отображения данных и перенаправления событий в игровом мире или действий пользователя. Это и есть MonoBehavior.
Не содержит в себе ничего, кроме логики отображения. Данные для отображения должны поступать из слоев Systems и Controllers.
Правильное MVC - нужно только для Ui. Но мы для простоты в качестве View можем воспринимать любой игровой объект, будь то кнопка с событием 
нажатия или игровой персонаж с событием столкновения.

## Controllers ##

Аналогично Systems - слой для выполнения бизнес-логики, но зависимой от действий со стороны пользователя или внутриигровых событий.
Каждый Controller должны ссылаться на экземпляр View.

## Data(Models) ##

Классы для хранения данных приложения. Тоже добавляются в DI-Container.
Используются для работы систем. Могут меняться в системах и контроллерах.
Для создания реактивных полей используется класс `RxField<TField>`.